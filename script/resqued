#!/usr/bin/env ruby
#/ Usage: resqued [-D] [-r <lib>] [-n <count>] [--queue <name>[=<num>%]]...
#/ Start the resque process manager and spawn worker processes.
#/
#/ Options
#/   -n, --workers <count>         Number of worker processes for all queues.
#/       --queue <name>[=<num>]    Work queue with a percentage (10%) or fixed
#/                                 number (10) of workers.
#/       --redis <url>             Connect to redis server at <url>.
#/   -r, --require <lib>           Require ruby library in master.
#/   -D, --daemonize               Run daemonized in the background.
#/   -v, --verbose                 Increase log verbosity; lots of debug info.
#/   -q, --quiet                   Decrease log verbosity; errors only.
#/
#/ Queues added first are processed fully before subsequent queues. Backlog on
#/ the first queue means workers will not visit the second queue.
require 'optparse'
$stderr.sync = true

# Command line option variables
daemonize        = false
worker_processes = 1
queue_defs       = []
require_libs     = []
redis            = nil

# Logging stuff
log_levels       = [:debug, :info, :warn, :error, :fatal, :unknown]
verbose          = log_levels.index(:warn)

# Parse arguments
file = __FILE__
ARGV.options do |opts|
  opts.on("-D", "--daemonize")             { |val| daemonize = val }
  opts.on("-n", "--workers=val", Integer)  { |val| worker_processes = val }
  opts.on("-r", "--require=val", String)   { |val| require_libs << val }
  opts.on("-Q", "--queue=val", String)     { |val| queue_defs << val }
  opts.on("--redis=val", String)           { |val| redis = val }
  opts.on("-v", "--verbose")               { |val| verbose = log_levels.index(:debug) }
  opts.on("-q", "--quiet")                 { |val| verbose = log_levels.index(:error) }
  opts.on_tail("-h", "--help")             { exec "grep ^#/<'#{file}'|cut -c4-" }
  opts.parse!
end

# Parse queue definitions into [queue_name, concurrency] pairs, performing
# conversion of strings to percentages or fixed numbers where needed.
queues = {}
queue_defs.each do |string|
  queue_name, concurrency = string.split("=", 2)
  queues[queue_name] =
    case concurrency
    when nil, '';    1.0
    when /%$/;       concurrency.chomp('%').to_i * 0.01
    else             concurrency.to_i
    end
end

# Load and configure some basic resque stuff
require 'resque'
Resque.logger.level = verbose
Resque.logger.formatter = Resque::VeryVerboseFormatter.new
Resque.logger.info "establishing redis connection: #{redis}"
Resque.redis = redis if redis

# Require any libraries requested with --require
require_libs.each { |lib| require(lib) }

# Build options
options = {
  :daemonize        => daemonize,
  :worker_processes => worker_processes
}

# Create the master and start spawning workers
require 'resqued'
master = ResqueDaemon::Master.new(queues, options)
master.run
