#!/usr/bin/env ruby
#/ Usage: resqued [-D] [-n <count>] [-c <config>] [-q <name>[=<workers>]]...
#/ Start a resque daemon.
#/
#/ Options
#/   -D, --daemonize             Run daemonized in the background.
#/   -c, --config <config>       Load resqued config file at <config>
#/   -n, --workers <count>       Number of workers to start for all queues.
#/   -q, --queue <name>[=<val>]  Process the queue with a percentage (10%)
#/                               or fixed number (10) of workers.
#/
#/ Queues added first are processed fully before subsequent queues. Backlog on
#/ the first queue means workers will not visit the second queue.
require 'optparse'
$stderr.sync = true

daemonize        = false
worker_processes = 1
config_file      = nil
queue_defs       = []

# parse arguments
file = __FILE__
ARGV.options do |opts|
  opts.on("-D", "--daemonize")             { |val| daemonize = val }
  opts.on("-n", "--workers=val", Integer)  { |val| worker_processes = val }
  opts.on("-c", "--config=val", String)    { |val| config_file = val }
  opts.on("-q", "--queue=val", String)     { |val| queue_defs << val }
  opts.on_tail("-h", "--help")             { exec "grep ^#/<'#{file}'|cut -c4-" }
  opts.parse!
end

# Parse queue definitions into [queue_name, concurrency] pairs, performing
# conversion of strings to percentages or fixed numbers where needed.
queues = {}
queue_defs.each do |string|
  queue_name, concurrency = string.split("=", 2)
  queues[queue_name] =
    case concurrency
    when nil, '';    1.0
    when /%$/;       concurrency.chomp('%').to_i * 0.01
    else             concurrency.to_i
    end
end

# Build options
options = {
  :daemonize        => daemonize,
  :worker_processes => worker_processes
}

require 'resqued'
master = ResqueDaemon::Master.new(queues, options)
master.run
